1. 引用 MultiplayerSession
2. 重定向动画
3. 创建c++类BlasterCharacter，创建蓝图类BP_BlasterCharacter
4. 通过项目设置->Input里的 ActionMappings、AxisMappings 来设置自己输入，并在BlasterCharacter类里创建对应函数进行处理
5. 创建c++BlasterAnimInstance，创建蓝图类BP_BlasterAnim并设置角色未穿戴装备时的动画
6. 无缝旅行与非无缝旅行
		无缝 Travel：无缝 Travel 是一种在不中断游戏流程的情况下切换场景或地图的方式。无缝 Travel 通常用于实现游戏中的波次、
				关卡等级或任何需要玩家移动到新的游戏区域的情景中。无缝 Travel 可以通过在服务器和客户端之间传输数据来实现无缝衔接。
		非无缝 Travel：非无缝 Travel 是指在切换场景或地图时会中断游戏流程的方式。当执行非无缝 Travel 时，游戏会先停止当前场景的运行，
				并加载新的场景或地图，然后重新启动游戏并初始化所需的数据和状态。非无缝 Travel 通常会中断客户端和服务器之间的连接，
				并在加载新地图或场景时重新建立连接，通常，非无缝 Travel 更适用于需要完全重置游戏状态的情况，例如从主菜单进入游戏或重新启动游戏等。
				
	创建一个过渡level，方便我们每次travel（	切场景）时设置无缝旅行一个场景到另一个场景，
	会创建一个游戏大厅，类似吃鸡进入游戏会先进入一个等待场景，有足够的玩家，就进入游戏。
	非无缝旅行：切地图会断开与服务器的连接，然后重新连接回同一台服务器，断开和重连都需要时间，重连可能会出现问题
	每次切场景首选使用无缝travel、首次加载地图以及连接到服务器时会发生非无缝travel。
	创建LobbyGameMode类，负责查看有多少玩家连接到大厅，一旦进入一定数量就可以前往实际的游戏地图
	
7. 创建c++ui小组件类OverheadWidget、蓝图类WBP_OverheadWidget
8. 创建c++武器类Weapon
9. 创建武器umg pickup组件，当玩家进入重叠时显示，退出隐藏
10. 创建战斗组件，通过项目设置->Input里的 ActionMappings设置按键E来拾取武器
11. 服务器控制客户端装备武器
12. 玩家装备武器后同步给其客户端显示武器，并在动画脚本中添加角色是否装备武器变量
13. 添加持枪下蹲动作
14. 实现瞄准、瞄准走动画
15. 添加瞄准偏移动画




1. 滞后补偿：
	插值法：角色从A点移动到B点，权威位置从服务器复制到客户端，客户端可以存储当前的服务器发来的更新和之前客户端进行的更新，
			在更新的时候在这两者之间进行差值。这种方法移动会使角色移动更顺畅，但是位置总是会回到过去，总是插值到当前的位置，
			这种延迟对射击角色很不利，在游戏中，因为向距离过去50毫秒的对手进行射击意味着你要错过
	外推法：如果知道对手在那个方向，可以假设角色会向这个方向移动，在等待下一次更新的同时继续移动角色，如果对手没有改变方向，
			这个方法非常有效，保持相同的速度。但是在快节奏的射击游戏中，玩家很少朝同一个方向移动，因此，当对手真正朝其他方向
			移动时，将角色向前移动会导致更加不准确。
	橡皮筋：在虚幻的移动组件中，将这两个方法进行了组合。
			如果你的ping非常高，你移动角色，角色移动组件将使用你的速度来推断你在其他机器上的位置，让你的角色移动。
			如果需要进行修正，角色移动组件会平滑地进行插值修正。如果服务器和客户端位置不同步，角色移动组件将使你的角色回到正确的位置
2. 服务器倒带：
	服务器跟踪玩家的位置，并以某种形式存储这些历史信息，当你命中目标时，你将命中的详细信息发送到服务器，包括命中的时间，
	然后服务器会查看你的命中时间，倒带时间，将玩家重新定位到之前的位置，并使用您的命中信息来查看您的子弹或直线是否跟踪，
	查看是否实际上打到服务器权威玩家，如果击中成功，就会获得分数奖励，然后服务器将所有角色放回到正确的位置并继续游戏。
	所以对于服务器端倒带客户端，客户端得分领先，然后告诉服务器，服务回退时间检查是否有效，就像客户端没有延迟一样。
	例1：现在，想象你正在玩一款射击游戏，假设你在一个漂亮的狙击点扎营，且一次网络消息需要50毫秒，正在等待一个毫无防备的对手经过，等待对手
		进入十字准心中开枪射击。在你对手的机器上，他们有一个他们控制的角色版本，在服务器上有这个对手的另外一个版本，在你的机器上还有一个版本，
		所以这个对手有三个不同版本，在你的机器上你会看到对手的复制版本，这个由server交付。现在，假设在50毫秒内，对手的角色可以移动n单位，你的
		狙击位置在40位置，所以你就需要等待对手进入你视线之前的一段时间，现在，当我们的时间是0毫秒时，我们会看到角色开始移动并且这个角色将继续
		以相同的速度每一帧移动，现在时间是0毫秒，因为对手只在自己的机器上移动了自己的角色，所以对手的本地位置在（1）10的位置，他需要通知服务
		器他已经移动了，所以他们会发送rpc，现在假设这个rpc需要50毫秒到达server，所以在50毫秒的时间内，我们的对手继续移动角色到20，并且服务器
		版本的对手角色也会向前推进并且将对手的位置同步给你的机器，此过程仍需50毫秒，此时对手机器角色位置在（2）20，server对手角色在10，自己机
		器上的角色在0位置，现在时间来到了100毫秒，对手继续移动角色到（3）30，server收到对手的rpc（2）并且server上的对手位置更新到20，然后将该
		位置同步给你，你自己的机器收到来server同步对手的位置消息（1），此时你自己机器上的对手位置更新到10，时间来到了150毫秒时，此时对手机器上
		的位置在（4）40，server的对手角色在30，你自己机器的对手角色位置到20，注意，此时对手本地位置已经在你的狙击位置，但是在我们的机器上还有
		一段距离，时间来到了200毫秒时，所有角色继续移动，rpc继续传播，对手位置本地（5）50，server40，你自己的机器对手位置在30，来到第250毫秒时，
		对手机器角色位置为（6）60，server为50，此时你自己机器上的对手角色移动到了40进入你的射击范围中，当你扣动扳机发送（A）rpc，服务器将在50毫秒后
		收到你的射击rpc，时间来到第300毫秒时，对手机器角色位置为（7）70，server为60，你自己机器对手的位置在50，此时server收到之前你机器发的射击
		rpc，server检查你发的对手位置40，但是在server上对手的角色已经移动到了60，所以这种滞后带来的判断是错误的。假设server能够倒带时间来查看所
		有角色在特定时间的位置，所以当你发送射击rpc时携带上开枪时间250毫秒，server拿这个时间去回退到250毫秒时，看对手角色是否在这个位置。
3. 客户端预测：
	假设一次网络消息往返时间时100毫秒（客户端发送消息到服务器50，服务器回消息到客户端50）。在客户端中一旦我们按下输入并移动，
	客户端将发送该消息到服务器，server验证后将移动复制到client，消息到达client，如果client发现位置与server不匹配，会更正到server的位置，
	网络抖动例子：一个角色在客户端，有一个它的相同版本在服务器，假设从0位置开始，client角色向前移动10单位，此时client发送rpc10到server，
		50毫秒后server接收到rpc，并将server角色向前移动10，然后server回消息发送权威位置10到client，50毫秒后client接收到rpc权威位置，
		此时由于client一直停留在10位置，已经在正确位置上，因此无需更正，这样做的好处是client在按下移动按钮后不必等待100毫秒才能看到角色的
		移动。
		再次假设从0位置开始，client角色向前移动10单位，发送rpc到server（1），50毫秒后server接收到rpc，并将server角色向前移动10，server回消息，
		此时客户端再次移动到20位置，发送rpc到server（2），现在到了100毫秒，client的新位置20到达了server，server将发送消息20，同一时刻client
		收到（1）的server回包10，但是此时client的位置是20，这意味着client不在权威位置上，就会看到角色往后拉回原来的位置，再接着50毫秒后，
		client回收到（2）server的回包20，此时角色又会被拉回到20的位置。这里在150毫秒内，角色会发生从0移动到10，然后到20，但是因为网络延迟，
		会将角色从20拉倒10，再10到20。
	发生网络抖动时，client可以对server的回包进行更正，对此称为服务器协调。
	服务器协调例子：一个角色在客户端，有一个它的相同版本在服务器，假设从0位置开始，现在时间为0毫秒时client角色向前移动10，此时client向server发送
		rpc并且client将缓存这一次rpc记录（1-10），所以client知道在第0毫秒的时候向server发送过rpc-10，时间来到了第50毫秒，现在client角色位置在10，
		server收到了来自client的第一个rpc消息位置10，server上的角色将移动到10位置并且向client发送rpc（1-10）来告知位置，同一时刻，client继续移动
		到20，意味着client将发送第二次rpc（2-20），同时client将缓存这个消息，这个时候客户端已经有了两次rpc发送记录（1-10,2-20）且仍没有收到server
		回复，所以client知道有两次rpc没有处理，时间再次过去50毫秒来到了第100毫秒，server收到了第二次client的rpc，将server的角色前进10来到第20位置，
		并且进行（2-20回包）给client，client这个时候收到了server的第一次rpc回包（1-10），根据client的缓存client可以知道这个server发送过来的是旧rpc，
		client知道发送过去的第二次rpc（2-20）还没处理，但是client知道这一次的server发来的rpc对应上client第一次发送过去的rpc，因此可以继续，并且丢弃
		第一次的rpc缓存。这里首先client告诉server角色位置是10，第二次rpc告诉server角色位置为20，所以client知道从第一个rpc到第二个rpc我们从10移动到了
		20，收到第一次server回rpc会先匹配到client的缓存10，并且client知道第二次的回包还没收到，所以这里client可以先行移动到20的位置。时间再次过去50
		毫秒来到了第150毫秒，client收到第二个rpc回包并应用于本地缓存，二次移动后client没有再继续移动，所以没有其它数据需要考虑，这里回包20和client
		目前位置20相匹配，所以不需要移动。通过缓存client发送到server的rpc，client可以先应用本地移动，同时client知道哪些更新尚未被server处理，以便后
		续进行更正。
		这里服务器协调过程：客户端输入后，先移动
							发送rpc到server，client缓存这个发送给server的rpc，此时client知道有一个未处理的rpc
							收到server回包，应用更正，丢弃已处理的rpc


1. 内存分析：
   1.1 LLM跟踪器	https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-the-low-level-memory-tracker-in-unreal-engine
		*在启动时加上 -LLM 参数 
			-LLM #启用LLM
   			-LLMCSV #连续将所有值写入CSV文件。自动启用-LLM。
   			-llmtagsets=Assets #实验性功能。显示每个资源分配的内存总计。
   			-llmtagsets=AssetClasses #实验性功能。显示每个UObject类类型的总计。
   		*直接启动 Standalone Game（独立游戏窗口），需要先在编辑器Edit里配置Additional Launch Parameters，添加-LLM -LLMCSV。
   		*通过 Visual Studio 调试启动（开发时常用）
   			在 Visual Studio 中右键你的启动项目（如 MyProject）→ Properties（属性）。
   			左侧选择：Debugging（调试）
   			在 Command Arguments（命令参数） 中输入：-LLM -LLMCSV。
   1.2 常用的 console command:
	   	stat memory #显示引擎中各个子系统的内存占用
       	stat MemoryAllocator #显示内存分配信息
       	stat MemoryPlatform #显示平台内存信息
       	stat MemoryStaticMesh #显示静态模型的内存信息
   1.3 Other
       	memreport
  		MemoryProfiler
       	Heapprofd(Android)
       	Instrument(IOS)
