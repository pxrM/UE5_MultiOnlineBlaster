1. 引用 MultiplayerSession
2. 重定向动画
3. 创建c++类BlasterCharacter，创建蓝图类BP_BlasterCharacter
4. 通过项目设置->Input里的 ActionMappings、AxisMappings 来设置自己输入，并在BlasterCharacter类里创建对应函数进行处理
5. 创建c++BlasterAnimInstance，创建蓝图类BP_BlasterAnim并设置角色未穿戴装备时的动画
6. 无缝旅行与非无缝旅行
		无缝 Travel：无缝 Travel 是一种在不中断游戏流程的情况下切换场景或地图的方式。无缝 Travel 通常用于实现游戏中的波次、
				关卡等级或任何需要玩家移动到新的游戏区域的情景中。无缝 Travel 可以通过在服务器和客户端之间传输数据来实现无缝衔接。
				
		非无缝 Travel：非无缝 Travel 是指在切换场景或地图时会中断游戏流程的方式。当执行非无缝 Travel 时，游戏会先停止当前场景的运行，
				并加载新的场景或地图，然后重新启动游戏并初始化所需的数据和状态。非无缝 Travel 通常会中断客户端和服务器之间的连接，
				并在加载新地图或场景时重新建立连接，通常，非无缝 Travel 更适用于需要完全重置游戏状态的情况，例如从主菜单进入游戏或重新启动游戏等。
				
	创建一个过渡level，方便我们每次travel（	切场景）时设置无缝旅行一个场景到另一个场景，
	会创建一个游戏大厅，类似吃鸡进入游戏会先进入一个等待场景，有足够的玩家，就进入游戏。
	非无缝旅行：切地图会断开与服务器的连接，然后重新连接回同一台服务器，断开和重连都需要时间，重连可能会出现问题
	每次切场景首选使用无缝travel、首次加载地图以及连接到服务器时会发生非无缝travel。
	创建LobbyGameMode类，负责查看有多少玩家连接到大厅，一旦进入一定数量就可以前往实际的游戏地图
	
7. 创建c++ui小组件类OverheadWidget、蓝图类WBP_OverheadWidget
8. 创建c++武器类Weapon
9. 创建武器umg pickup组件，当玩家进入重叠时显示，退出隐藏
10. 创建战斗组件，通过项目设置->Input里的 ActionMappings设置按键E来拾取武器
11. 服务器控制客户端装备武器
12. 玩家装备武器后同步给其客户端显示武器，并在动画脚本中添加角色是否装备武器变量
13. 添加持枪下蹲动作
14. 实现瞄准、瞄准走动画
15. 添加瞄准偏移动画




滞后补偿：
	插值法：角色从A点移动到B点，权威位置从服务器复制到客户端，客户端可以存储当前的服务器发来的更新和之前客户端进行的更新，
			在更新的时候在这两者之间进行差值。这种方法移动会使角色移动更顺畅，但是位置总是会回到过去，总是插值到当前的位置，
			这种延迟对射击角色很不利，在游戏中，因为向距离过去50毫秒的对手进行射击意味着你要错过
	外推法：如果知道对手在那个方向，可以假设角色会向这个方向移动，在等待下一次更新的同时继续移动角色，如果对手没有改变方向，
			这个方法非常有效，保持相同的速度。但是在快节奏的射击游戏中，玩家很少朝同一个方向移动，因此，当对手真正朝其他方向
			移动时，将角色向前移动会导致更加不准确。
	橡皮筋：在虚幻的移动组件中，将这两个方法进行了组合。
			如果你的ping非常高，你移动角色，角色移动组件将使用你的速度来推断你在其他机器上的位置，让你的角色移动。
			如果需要进行修正，角色移动组件会平滑地进行插值修正。如果服务器和客户端位置不同步，角色移动组件将使你的角色回到正确的位置
服务器倒带：
	服务器跟踪玩家的位置，并以某种形式存储这些历史信息，当你命中目标时，你将命中的详细信息发送到服务器，包括命中的时间，
	然后服务器会查看你的命中时间，倒带时间，将玩家重新定位到之前的位置，并使用您的命中信息来查看您的子弹或直线是否跟踪，
	查看是否实际上打到服务器权威玩家，如果击中成功，就会获得分数奖励，然后服务器将所有角色放回到正确的位置并继续游戏。
	所以对于服务器端倒带客户端，客户端得分领先，然后告诉服务器，服务回退时间检查是否有效，就像客户端没有延迟一样。
客户端预测：
	假设一次网络消息往返时间时100毫秒（客户端发送消息到服务器50，服务器回消息到客户端50）。在客户端中一旦我们按下输入并移动，
	客户端将发送该消息到服务器，server验证后将移动复制到client，消息到达client，如果client发现位置与server不匹配，会更正到server的位置，
	网络抖动例子：一个角色在客户端，有一个它的相同版本在服务器，假设从0位置开始，client角色向前移动10单位，此时client发送rpc10到server，
		50毫秒后server接收到rpc，并将server角色向前移动10，然后server回消息发送权威位置10到client，50毫秒后client接收到rpc权威位置，
		此时由于client一直停留在10位置，已经在正确位置上，因此无需更正，这样做的好处是client在按下移动按钮后不必等待100毫秒才能看到角色的
		移动。
		再次假设从0位置开始，（1）client角色向前移动10单位，发送rpc到server，50毫秒后server接收到rpc，并将server角色向前移动10，server回消息，
		（2）此时客户端再次移动到20位置，发送rpc到server，现在到了100毫秒，client的新位置20到达了server，server将发送消息20，同一时刻client
		收到（1）的server回包10，但是此时client的位置是20，这意味着client不在权威位置上，就会看到角色往后拉回原来的位置，再接着50毫秒后，
		client回收到（2）server的回包20，此时角色又会被拉回到20的位置。这里在150毫秒内，角色会发生从0移动到10，然后到20，但是因为网络延迟，
		会将角色从20拉倒10，再10到20。
	发生网络抖动时，client可以对server的回包进行更正，对此称为服务器协调。
	服务器协调例子：一个角色在客户端，有一个它的相同版本在服务器，假设从0位置开始，现在时间为0毫秒时client角色向前移动10，此时client向server发送
		rpc并且client将缓存这一次rpc记录（1-10），所以client知道在第0毫秒的时候向server发送过rpc-10，时间来到了第50毫秒，现在client角色位置在10，
		server收到了来自client的第一个rpc消息位置10，server上的角色将移动到10位置并且向client发送rpc（1-10）来告知位置，同一时刻，client继续移动
		到20，意味着client将发送第二次rpc（2-20），同时client将缓存这个消息，这个时候客户端已经有了两次rpc发送记录（1-10,2-20）且仍没有收到server
		回复，所以client知道有两次rpc没有处理，时间再次过去50毫秒来到了第100毫秒，server收到了第二次client的rpc，将server的角色前进10来到第20位置，
		并且进行（2-20回包）给client，client这个时候收到了server的第一次rpc回包（1-10），根据client的缓存client可以知道这个server发送过来的是旧rpc，
		client知道发送过去的第二次rpc（2-20）还没处理，但是client知道这一次的server发来的rpc对应上client第一次发送过去的rpc，因此可以继续，并且丢弃
		第一次的rpc缓存。这里首先client告诉server角色位置是10，第二次rpc告诉server角色位置为20，可以得出两次rpc中角色移动的距离是10（10-20），